{
  "__STD_C": "0",
  "Void_t": "char",
  "assert": "(expr) ((expr) ? ((void) 0) : __malloc_assert (__STRING (expr), __FILE__, __LINE__, __func__))",
  "INTERNAL_SIZE_T": "size_t",
  "SIZE_SZ": "(sizeof(INTERNAL_SIZE_T))",
  "MALLOC_ALIGNMENT": "(2 * SIZE_SZ)",
  "MALLOC_ALIGN_MASK": "(MALLOC_ALIGNMENT - 1)",
  "REALLOC_ZERO_BYTES_FREES": "1",
  "TRIM_FASTBINS": "0",
  "public_cALLOc": "calloc",
  "public_fREe": "free",
  "public_cFREe": "cfree",
  "public_mALLOc": "malloc",
  "public_mEMALIGn": "memalign",
  "public_rEALLOc": "realloc",
  "public_vALLOc": "valloc",
  "public_pVALLOc": "pvalloc",
  "public_mALLINFo": "mallinfo",
  "public_mALLOPt": "mallopt",
  "public_mTRIm": "malloc_trim",
  "public_mSTATs": "malloc_stats",
  "public_mUSABLe": "malloc_usable_size",
  "public_iCALLOc": "independent_calloc",
  "public_iCOMALLOc": "independent_comalloc",
  "public_gET_STATe": "malloc_get_state",
  "public_sET_STATe": "malloc_set_state",
  "malloc_getpagesize": "(4096)",
  "open": "__open",
  "mmap": "__mmap",
  "munmap": "__munmap",
  "mremap": "__mremap",
  "mprotect": "__mprotect",
  "MORECORE": "sbrk",
  "MORECORE_FAILURE": "(-1)",
  "__builtin_expect": "(expr, val)(expr)",
  "fwrite": "(buf, size, count, fp) _IO_fwrite (buf, size, count, fp)",
  "HAVE_MEMCPY": "",
  "USE_MEMCPY": "0",
  "force_reg": "(val) ({ __typeof (val) _v; asm (\"\" : \"=r\" (_v) : \"0\" (val)); _v; })",
  "MALLOC_FAILURE_ACTION": "",
  "MORECORE_CONTIGUOUS": "1",
  "MORECORE_CLEARS": "1",
  "HAVE_MMAP": "1",
  "MMAP_CLEARS": "0",
  "MMAP_AS_MORECORE_SIZE": "(1024 * 1024)",
  "HAVE_MREMAP": "0",
  "USE_ARENAS": "HAVE_MMAP",
  "_SC_PAGE_SIZE": "_SC_PAGESIZE",
  "M_MXFAST": "1",
  "DEFAULT_MXFAST": "(64 * SIZE_SZ / 4)",
  "M_TRIM_THRESHOLD": "-1",
  "DEFAULT_TRIM_THRESHOLD": "(128 * 1024)",
  "M_TOP_PAD": "-2",
  "DEFAULT_TOP_PAD": "(0)",
  "DEFAULT_MMAP_THRESHOLD_MIN": "(128 * 1024)",
  "DEFAULT_MMAP_THRESHOLD_MAX": "(4 * 1024 * 1024 * sizeof(long))",
  "M_MMAP_THRESHOLD": "-3",
  "DEFAULT_MMAP_THRESHOLD": "DEFAULT_MMAP_THRESHOLD_MIN",
  "M_MMAP_MAX": "-4",
  "DEFAULT_MMAP_MAX": "(0)",
  "BOUNDED_N": "(ptr, sz) (ptr)",
  "RETURN_ADDRESS": "(X_) (NULL)",
  "internal_function": "",
  "NO_STARTER": "",
  "MALLOC_COPY": "(dest,src,nbytes) do { INTERNAL_SIZE_T* mcsrc = (INTERNAL_SIZE_T*) src; INTERNAL_SIZE_T* mcdst = (INTERNAL_SIZE_T*) dest; unsigned long mctmp = (nbytes)/sizeof(INTERNAL_SIZE_T); long mcn; if (mctmp < 8) mcn = 0; else { mcn = (mctmp-1)/8; mctmp %= 8; } switch (mctmp) { case 0: for(;;) { *mcdst++ = *mcsrc++; case 7: *mcdst++ = *mcsrc++; case 6: *mcdst++ = *mcsrc++; case 5: *mcdst++ = *mcsrc++; case 4: *mcdst++ = *mcsrc++; case 3: *mcdst++ = *mcsrc++; case 2: *mcdst++ = *mcsrc++; case 1: *mcdst++ = *mcsrc++; if(mcn <= 0) break; mcn--; } } } while(0)",
  "MALLOC_ZERO": "(charp, nbytes) do { INTERNAL_SIZE_T* mzp = (INTERNAL_SIZE_T*)(charp); unsigned long mctmp = (nbytes)/sizeof(INTERNAL_SIZE_T); long mcn; if (mctmp < 8) mcn = 0; else { mcn = (mctmp-1)/8; mctmp %= 8; } switch (mctmp) { case 0: for(;;) { *mzp++ = 0; case 7: *mzp++ = 0; case 6: *mzp++ = 0; case 5: *mzp++ = 0; case 4: *mzp++ = 0; case 3: *mzp++ = 0; case 2: *mzp++ = 0; case 1: *mzp++ = 0; if(mcn <= 0) break; mcn--; } } } while(0)",
  "MAP_ANONYMOUS": "MAP_ANON",
  "MAP_FAILED": "((char*)-1)",
  "MAP_NORESERVE": "0",
  "MMAP": "(addr, size, prot, flags) (mmap((addr), (size), (prot), (flags)|MAP_ANONYMOUS, -1, 0))",
  "chunk2mem": "(p) ((Void_t*)((char*)(p) + 2*SIZE_SZ))",
  "mem2chunk": "(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))",
  "MIN_CHUNK_SIZE": "(offsetof(struct malloc_chunk, fd_nextsize))",
  "MINSIZE": "(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))",
  "aligned_OK": "(m) (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)",
  "misaligned_chunk": "(p) ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) & MALLOC_ALIGN_MASK)",
  "REQUEST_OUT_OF_RANGE": "(req) ((unsigned long)(req) >= (unsigned long)(INTERNAL_SIZE_T)(-2 * MINSIZE))",
  "request2size": "(req) (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE) ? MINSIZE : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)",
  "checked_request2size": "(req, sz) if (REQUEST_OUT_OF_RANGE(req)) { MALLOC_FAILURE_ACTION; return 0; } (sz) = request2size(req);",
  "PREV_INUSE": "0x1",
  "prev_inuse": "(p) ((p)->size & PREV_INUSE)",
  "IS_MMAPPED": "0x2",
  "chunk_is_mmapped": "(p) ((p)->size & IS_MMAPPED)",
  "NON_MAIN_ARENA": "0x4",
  "chunk_non_main_arena": "(p) ((p)->size & NON_MAIN_ARENA)",
  "SIZE_BITS": "(PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)",
  "chunksize": "(p) ((p)->size & ~(SIZE_BITS))",
  "next_chunk": "(p) ((mchunkptr)( ((char*)(p)) + ((p)->size & ~SIZE_BITS) ))",
  "prev_chunk": "(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_size) ))",
  "chunk_at_offset": "(p, s) ((mchunkptr)(((char*)(p)) + (s)))",
  "inuse": "(p)((((mchunkptr)(((char*)(p))+((p)->size & ~SIZE_BITS)))->size) & PREV_INUSE)",
  "set_inuse": "(p)((mchunkptr)(((char*)(p)) + ((p)->size & ~SIZE_BITS)))->size |= PREV_INUSE",
  "clear_inuse": "(p)((mchunkptr)(((char*)(p)) + ((p)->size & ~SIZE_BITS)))->size &= ~(PREV_INUSE)",
  "inuse_bit_at_offset": "(p, s) (((mchunkptr)(((char*)(p)) + (s)))->size & PREV_INUSE)",
  "set_inuse_bit_at_offset": "(p, s) (((mchunkptr)(((char*)(p)) + (s)))->size |= PREV_INUSE)",
  "clear_inuse_bit_at_offset": "(p, s) (((mchunkptr)(((char*)(p)) + (s)))->size &= ~(PREV_INUSE))",
  "set_head_size": "(p, s) ((p)->size = (((p)->size & SIZE_BITS) | (s)))",
  "set_head": "(p, s) ((p)->size = (s))",
  "set_foot": "(p, s) (((mchunkptr)((char*)(p) + (s)))->prev_size = (s))",
  "bin_at": "(m, i) (mbinptr) (((char *) &((m)->bins[((i) - 1) * 2])) - offsetof (struct malloc_chunk, fd))",
  "next_bin": "(b) ((mbinptr)((char*)(b) + (sizeof(mchunkptr)<<1)))",
  "first": "(b) ((b)->fd)",
  "last": "(b) ((b)->bk)",
  "unlink": "(P, BK, FD) { FD = P->fd; BK = P->bk; if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) malloc_printerr (check_action, \"corrupted double-linked list\", P); else { FD->bk = BK; BK->fd = FD; if (!in_smallbin_range (P->size) && __builtin_expect (P->fd_nextsize != NULL, 0)) { assert (P->fd_nextsize->bk_nextsize == P); assert (P->bk_nextsize->fd_nextsize == P); if (FD->fd_nextsize == NULL) { if (P->fd_nextsize == P) FD->fd_nextsize = FD->bk_nextsize = FD; else { FD->fd_nextsize = P->fd_nextsize; FD->bk_nextsize = P->bk_nextsize; P->fd_nextsize->bk_nextsize = FD; P->bk_nextsize->fd_nextsize = FD; } }else { P->fd_nextsize->bk_nextsize = P->bk_nextsize; P->bk_nextsize->fd_nextsize = P->fd_nextsize; } } } }",
  "NBINS": "128",
  "NSMALLBINS": "64",
  "SMALLBIN_WIDTH": "MALLOC_ALIGNMENT",
  "MIN_LARGE_SIZE": "(NSMALLBINS * SMALLBIN_WIDTH)",
  "in_smallbin_range": "(sz) ((unsigned long)(sz) < (unsigned long)MIN_LARGE_SIZE)",
  "smallbin_index": "(sz) (SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) >> 4) : (((unsigned)(sz)) >> 3))",
  "largebin_index_32": "(sz) (((((unsigned long)(sz)) >> 6) <= 38)? 56 + (((unsigned long)(sz)) >> 6): ((((unsigned long)(sz)) >> 9) <= 20)? 91 + (((unsigned long)(sz)) >> 9): ((((unsigned long)(sz)) >> 12) <= 10)? 110 + (((unsigned long)(sz)) >> 12): ((((unsigned long)(sz)) >> 15) <= 4)? 119 + (((unsigned long)(sz)) >> 15): ((((unsigned long)(sz)) >> 18) <= 2)? 124 + (((unsigned long)(sz)) >> 18): 126)",
  "largebin_index_64": "(sz) (((((unsigned long)(sz)) >> 6) <= 48)? 48 + (((unsigned long)(sz)) >> 6): ((((unsigned long)(sz)) >> 9) <= 20)? 91 + (((unsigned long)(sz)) >> 9): ((((unsigned long)(sz)) >> 12) <= 10)? 110 + (((unsigned long)(sz)) >> 12): ((((unsigned long)(sz)) >> 15) <= 4)? 119 + (((unsigned long)(sz)) >> 15): ((((unsigned long)(sz)) >> 18) <= 2)? 124 + (((unsigned long)(sz)) >> 18): 126)",
  "largebin_index": "(sz) (SIZE_SZ == 8 ? largebin_index_64 (sz) : largebin_index_32 (sz))",
  "bin_index": "(sz) ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))",
  "unsorted_chunks": "(M) (bin_at(M, 1))",
  "initial_top": "(M) (unsorted_chunks(M))",
  "BINMAPSHIFT": "5",
  "BITSPERMAP": "(1U << BINMAPSHIFT)",
  "BINMAPSIZE": "(NBINS / BITSPERMAP)",
  "idx2block": "(i) ((i) >> BINMAPSHIFT)",
  "idx2bit": "(i) ((1U << ((i) & ((1U << BINMAPSHIFT)-1))))",
  "mark_bin": "(m,i) ((m)->binmap[idx2block(i)] |= idx2bit(i))",
  "unmark_bin": "(m,i) ((m)->binmap[idx2block(i)] &= ~(idx2bit(i)))",
  "get_binmap": "(m,i) ((m)->binmap[idx2block(i)] & idx2bit(i))",
  "fastbin": "(ar_ptr, idx) ((ar_ptr)->fastbinsY[idx])",
  "fastbin_index": "(sz) ((((unsigned int)(sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)",
  "MAX_FAST_SIZE": "(80 * SIZE_SZ / 4)",
  "NFASTBINS": "(fastbin_index(request2size(MAX_FAST_SIZE))+1)",
  "FASTBIN_CONSOLIDATION_THRESHOLD": "(65536UL)",
  "FASTCHUNKS_BIT": "(1U)",
  "have_fastchunks": "(M) (((M)->flags & FASTCHUNKS_BIT) == 0)",
  "clear_fastchunks": "(M) ((M)->flags |= FASTCHUNKS_BIT)",
  "set_fastchunks": "(M) ((M)->flags &= ~FASTCHUNKS_BIT)",
  "NONCONTIGUOUS_BIT": "(2U)",
  "contiguous": "(M) (((M)->flags & NONCONTIGUOUS_BIT) == 0)",
  "noncontiguous": "(M) (((M)->flags & NONCONTIGUOUS_BIT) != 0)",
  "set_noncontiguous": "(M) ((M)->flags |= NONCONTIGUOUS_BIT)",
  "set_contiguous": "(M) ((M)->flags &= ~NONCONTIGUOUS_BIT)",
  "set_max_fast": "(s) global_max_fast = ((s) == 0)? SMALLBIN_WIDTH: request2size(s)",
  "get_max_fast": "() global_max_fast",
  "M_ARENA_TEST": "-7",
  "M_ARENA_MAX": "-8",
  "weak_variable": "weak_function",
  "DEFAULT_CHECK_ACTION": "3",
  "alloc_perturb": "(p, n) memset (p, (perturb_byte ^ 0xff) & 0xff, n)",
  "free_perturb": "(p, n) memset (p, perturb_byte & 0xff, n)",
  "check_chunk": "(A,P) do_check_chunk(A,P)",
  "check_free_chunk": "(A,P) do_check_free_chunk(A,P)",
  "check_inuse_chunk": "(A,P) do_check_inuse_chunk(A,P)",
  "check_remalloced_chunk": "(A,P,N) do_check_remalloced_chunk(A,P,N)",
  "check_malloced_chunk": "(A,P,N) do_check_malloced_chunk(A,P,N)",
  "check_malloc_state": "(A) do_check_malloc_state(A)",
  "HALF_INTERNAL_SIZE_T": "(((INTERNAL_SIZE_T) 1) << (8 * sizeof (INTERNAL_SIZE_T) / 2))",
  "MAX_ITERS": "10000",
  "nsizes": "(sizeof (sizes) / sizeof (sizes[0]))"
}